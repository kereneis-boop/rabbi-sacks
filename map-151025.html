<script>
(function(){
  let data; 
  try { 
    data = JSON.parse(document.getElementById('mindmap-data').textContent); 
  } catch(e){ 
    console.error('Mindmap JSON parse error:', e); 
    data = {"dir":"rtl","flow":"rtl","root":{"label":"שגיאת נתונים - נא לבדוק JSON","children":[]}};
  }

  const DIR = (data.dir||'rtl'); document.documentElement.setAttribute('dir', DIR);
  const FLOW = (data.flow||'rtl');
  const viewport = document.getElementById('viewport');
  if(viewport) viewport.style.direction = 'ltr';
  const stage = document.getElementById('app');
  const scroller = document.getElementById('scroller');
  const chipLayer = document.getElementById('chips');
  const edgeLayer = document.getElementById('edges');

  let mode = 'fitW', userScale = 1, lockedFit = 1;
  let pinchStartDist = 0, pinchStartScale = 1;

  if(FLOW==='ltr'){ stage.style.transformOrigin = 'top left'; stage.style.left='0'; stage.style.right=''; }
  else            { stage.style.transformOrigin = 'top right'; stage.style.right='0'; stage.style.left=''; }
  stage.style.top='0'; stage.style.position='absolute';

  const CSS = getComputedStyle(document.documentElement);
  const CHIP_H  = parseFloat(CSS.getPropertyValue('--chip-h'))   || 48;
  const GAP_X   = parseFloat(CSS.getPropertyValue('--gap-x'))    || 36; 
  const GAP_Y   = parseFloat(CSS.getPropertyValue('--gap-y'))    || 40;
  const GAP_BETWEEN_MODS_D2 = parseFloat(CSS.getPropertyValue('--gap-between-mods-d2')) || 20;
  const GAP_ROOTCAT = parseFloat(CSS.getPropertyValue('--gap-rootcat')) || 22;
  const GAP_CAT = parseFloat(CSS.getPropertyValue('--gap-cat'))  || 22;
  const GAP_ITEM= parseFloat(CSS.getPropertyValue('--gap-item')) || 6;
  const GAP_X_D01 = parseFloat(CSS.getPropertyValue('--gap-x-d01')) || GAP_X;
  const GAP_D3 = parseFloat(CSS.getPropertyValue('--gap-d3')) || GAP_ITEM;
  const GAP_D4 = parseFloat(CSS.getPropertyValue('--gap-d4')) || GAP_ITEM;

  const DEPTH_COLORS = {0:'#F8E8FF', 1:'#EBDCF8', 2:'#D4D2E6', 3:'#D7F6E4', 4:'#50E38A'};

  const gapForDepth = (d)=> d>=4 ? GAP_D4 : d===3 ? GAP_D3 : d===2 ? GAP_CAT : d===1 ? GAP_ROOTCAT : GAP_Y;

  // === בנייה: דיפולט סוגר עומקים >= 2 ===
  function build(raw, depth=0, parent=null){
    const defaultCollapsed = (depth >= 2);
    const node = {
      label: raw.label,
      depth,
      parent,
      collapsed: ('collapsed' in raw) ? !!raw.collapsed : defaultCollapsed,
      x:0, y:0, width:0, height:CHIP_H, el:null, id: Math.random().toString(36).slice(2),
      _subH:0, children: [],
      gapOverride: (typeof raw.gap==='number'? raw.gap : null)
    };
    (raw.children||[]).forEach(ch=> node.children.push(build(ch, depth+1, node)));
    return node;
  }
  const root = build(data.root, 0, null);

  // יצירת קפסולות
  function ensureChip(node){
    if(node.el) return;
    const el = document.createElement('div'); el.className = 'chip';
    el.dataset.kind = node.depth===0 ? 'root' : (node.children.length? 'cat':'leaf');
    const label = document.createElement('span'); label.className='label'; label.textContent=node.label; el.appendChild(label);
    if(node.children.length){
      const t = document.createElement('button');
      t.className = 'toggle'; t.setAttribute('aria-label','פתח/סגור');
      t.innerHTML = '<i class="bar h"></i><i class="bar v"></i>';
      el.appendChild(t);
      el.setAttribute('aria-expanded', String(!node.collapsed));
      t.addEventListener('click', ev => { ev.stopPropagation(); handleToggle(node); });
      el.setAttribute('tabindex','0'); el.setAttribute('role','button');
      el.addEventListener('keydown', ev=>{ if(ev.key==='Enter' || ev.key===' '){ ev.preventDefault(); handleToggle(node); } });
    }
    el.style.setProperty('--chip-bg', DEPTH_COLORS[Math.min(node.depth,4)] || DEPTH_COLORS[4]);
    chipLayer.appendChild(el); node.el=el;
  }
  (function collect(n){ ensureChip(n); n.children.forEach(collect); })(root);

  // מדידה
  function measure(node){
    node.el.style.left = '-10000px';
    node.el.style.top = '-10000px';
    node.width = Math.max(140, node.el.offsetWidth);
    node.children.forEach(measure);
  }

  function subHeight(node){
    if(node.collapsed || node.children.length===0){ node._subH = node.height; return node._subH; }
    let total = 0;
    node.children.forEach((c,i)=>{
      subHeight(c);
      total += c._subH;
      if(i>0) total += (node.gapOverride != null) ? node.gapOverride : gapForDepth(c.depth);
    });
    node._subH = Math.max(node.height, total); return node._subH;
  }

  // עוגנים
  let DEPTH_ANCHORS = new Map();
  const xForDepth = (d)=> DEPTH_ANCHORS.get(d) || 0;

  function position(node, depth, top){
    node.x = xForDepth(depth);
    node.y = top + node._subH/2;
    if(!(node.collapsed) && node.children.length){
      let cursor = top;
      node.children.forEach((c,idx)=>{
        position(c, depth+1, cursor);
        cursor += c._subH + gapForDepth(c.depth);
        if(node.depth===0 && idx < node.children.length-1){ cursor += GAP_BETWEEN_MODS_D2; }
      });
    }
  }

  function collectVisible(n, arr){ arr.push(n); if(!n.collapsed) n.children.forEach(ch=>collectVisible(ch, arr)); }
  function computeBounds(nodes){
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    nodes.forEach(n=>{
      const left  = (FLOW==='rtl' ? n.x - n.width : n.x);
      const right = (FLOW==='rtl' ? n.x : n.x + n.width);
      minX = Math.min(minX, left);
      maxX = Math.max(maxX, right);
      minY = Math.min(minY, n.y - n.height/2);
      maxY = Math.max(maxY, n.y + n.height/2);
    });
    return { w:(maxX-minX), h:(maxY-minY), minX };
  }

  const SHOW_GUIDES = false;
  let lastW = 0, lastH = 0, offsetX = 0, stageW = 0;
  const edgeOf = new Map();

  // SHIFT ויזואלי רק לשורש (לא מזיז את הילדים)
  let rootYOffset = 0;

  function layout(){
    measure(root);

    // עוגנים דינמיים לפי רוחב מקס' בכל עומק
    subHeight(root); position(root,0,0);
    let nodesTmp=[]; collectVisible(root, nodesTmp);
    const depthMaxW = new Map();
    nodesTmp.forEach(n=> depthMaxW.set(n.depth, Math.max(depthMaxW.get(n.depth)||0, n.width||140)));
    DEPTH_ANCHORS = new Map(); DEPTH_ANCHORS.set(0, 0);
    let acc=0; const maxDepthVis = nodesTmp.reduce((m,n)=>Math.max(m,n.depth),0);
    for(let d=1; d<=maxDepthVis+1; d++){
      const addGap = (d===1 ? GAP_X_D01 : GAP_X);
      acc += (depthMaxW.get(d-1)||140) + addGap;
      DEPTH_ANCHORS.set(d, (FLOW==='rtl' ? -acc : acc));
    }

    // מיקום סופי
    subHeight(root); position(root, 0, 0);

    // === מירכוז ויזואלי של השורש מול עומק-1 ===
    rootYOffset = 0;
    if (root.children && root.children.length){
      const firstY = root.children[0].y;
      const lastY  = root.children[root.children.length - 1].y;
      const desired = (firstY + lastY) / 2;
      rootYOffset = desired - root.y; // רק להצגה/שרטוט
    }

    const nodes=[]; collectVisible(root, nodes);
    const { w, h, minX } = computeBounds(nodes);

    // Fit לרוחב
    const vpW = viewport.getBoundingClientRect().width;
    const FIT_MARGIN = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fit-margin')) || 24;
    const baseFit = Math.min(1.0, (vpW - FIT_MARGIN) / Math.max(1, w));
    const maxDepthNow = nodes.reduce((m,n)=> Math.max(m, n.depth), 0);
    let compactCap = 1.0; if(maxDepthNow<=1) compactCap=0.75; else if(maxDepthNow===2) compactCap=0.88;
    const requiredFit = Math.max(0.2, Math.min(baseFit, compactCap));

    if(mode==='fitW'){
      lockedFit = requiredFit;
      const RIGHT_PAD = 24, LEFT_PAD = 24;
      offsetX = -minX + (LEFT_PAD/lockedFit);
      stageW  = w + (LEFT_PAD+RIGHT_PAD)/lockedFit;
    } else {
      const sNow = Math.max((mode==='fitW') ? lockedFit : userScale, 0.0001);
      const desiredPad = Math.max(60, Math.floor((viewport.clientWidth/sNow - w)/2) + 40);
      offsetX = -minX + desiredPad;
      stageW  = w + desiredPad*2;
    }

    lastW = stageW; lastH = h;
    stage.style.width  = Math.ceil(stageW) + 'px';
    stage.style.height = Math.ceil(h) + 'px';

    // מיקום קפסולות (עם יישור שורש בלבד)
    const sPlace = (mode==='fitW') ? lockedFit : userScale;
    nodes.forEach(n=>{
      const yAdj = (n===root ? rootYOffset : 0);
      const top = (n.y + yAdj) - n.height/2;
      const anchorUnits = offsetX + n.x;
      const anchorPx    = Math.round(anchorUnits * Math.max(sPlace,0.0001));
      const snapped     = anchorPx / Math.max(sPlace,0.0001);
      const leftUnits   = FLOW==='rtl' ? (snapped - n.width) : snapped;
      n.el.style.right = '';
      n.el.style.left  = leftUnits + 'px';
      n.el.style.top   = top + 'px';
      if(n.children.length){ n.el.setAttribute('aria-expanded', String(!n.collapsed)); }
    });

    // קווים
    edgeOf.clear(); edgeLayer.textContent='';
    if(SHOW_GUIDES){
      DEPTH_ANCHORS.forEach((ax, d)=>{
        const sNow = Math.max((mode==='fitW') ? lockedFit : userScale, 0.0001);
        const rx = (Math.round((offsetX + ax) * sNow))/sNow;
        const g = document.createElementNS('http://www.w3.org/2000/svg','path');
        g.setAttribute('class','edge'); g.setAttribute('stroke-dasharray','4 6'); g.setAttribute('opacity','0.25');
        g.setAttribute('d', `M ${rx} 0 L ${rx} ${lastH||1000}`);
        edgeLayer.appendChild(g);
      });
    }
    (function draw(n){ if(n.collapsed) return; n.children.forEach(ch=>{
      const PAD_PARENT=6, PAD_CHILD=0;
      const sNow = Math.max((mode==='fitW') ? lockedFit : userScale, 0.0001);
      const parentAnchor = (Math.round((offsetX + n.x) * sNow)) / sNow;
      const childAnchor  = (Math.round((offsetX + ch.x) * sNow)) / sNow;
      const p1x = (FLOW==='rtl') ? (parentAnchor - PAD_PARENT) : (parentAnchor + n.width - PAD_PARENT);
      const p2x = (FLOW==='rtl') ? (childAnchor  - PAD_CHILD)  : (childAnchor  + PAD_CHILD);
      const p1y = n.y + (n===root ? rootYOffset : 0);
      const p2y = ch.y + (ch===root ? rootYOffset : 0);
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      const dx=Math.abs(p2x-p1x)*.45, c1x=(FLOW==='rtl'? p1x-dx: p1x+dx), c2x=(FLOW==='rtl'? p2x+dx: p2x-dx);
      path.setAttribute('class','edge');
      path.setAttribute('d', `M ${p1x} ${p1y} C ${c1x} ${p1y}, ${c2x} ${p2y}, ${p2x} ${p2y}`);
      edgeOf.set(ch.id, path); edgeLayer.appendChild(path);
      draw(ch);
    }); })(root);

    applyZoom();
    stage.style.opacity='1';
  }

  function applyZoom(){
    const s = (mode==='fitW') ? lockedFit : userScale;
    stage.style.transform = `scale(${s})`;
    const pct = document.getElementById('zoomPct'); if(pct) pct.textContent = Math.round(s*100)+"%";
    if(lastW && lastH){
      const wpx = (mode==='fitW') ? Math.floor(viewport.clientWidth) : Math.ceil(lastW * s);
      scroller.style.width  = wpx + 'px';
      scroller.style.height = Math.ceil(lastH * s) + 'px';
    }
    const tol = 2;
    let needX = (mode!=='fitW') && ((scroller.offsetWidth - viewport.clientWidth) > tol);
    let needY = (scroller.offsetHeight - viewport.clientHeight) > tol;
    if(mode==='fitW'){
      needX = false;
      if(lastH && (lastH * Math.max(lockedFit, 0.0001) <= viewport.clientHeight - tol)) needY = false;
    }
    viewport.style.overflowX = needX ? 'auto' : 'hidden';
    viewport.style.overflowY = needY ? 'auto' : 'hidden';
    viewport.style.cursor    = (needX || needY) ? 'grab' : 'auto';
  }

  // Toggle
  function collapseDeep(n){ n.collapsed = true; n.children.forEach(c=>collapseDeep(c)); }
  function animateClose(node, done){
    const list=[]; function collectDesc(n){ if(!n || n.collapsed) return; list.push(n); n.children.forEach(collectDesc); }
    node.children.forEach(collectDesc);
    const dur = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--anim-dur'))*1000+20;
    list.forEach(n=>{
      if(n.el){ n.el.classList.add('fade-exit'); requestAnimationFrame(()=> n.el.classList.add('fade-active')); setTimeout(()=> n.el.classList.remove('fade-exit','fade-active'), dur); }
      const edge = edgeOf.get(n.id); if(edge){ edge.classList.add('fade-exit'); requestAnimationFrame(()=> edge.classList.add('fade-active')); setTimeout(()=> edge.classList.remove('fade-exit','fade-active'), dur); }
    });
    setTimeout(done, dur);
  }
  function handleToggle(n){ 
    if(n.collapsed){ 
      if(n.el) n.el.setAttribute('aria-expanded','true'); 
      n.collapsed=false; 
      layout(); 
    } else { 
      if(n.el) n.el.setAttribute('aria-expanded','false'); 
      animateClose(n, ()=>{ collapseDeep(n); layout(); }); 
    } 
  }

  // Zoom + Pan
  const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
  const currentScale = ()=> (mode==='fitW' ? lockedFit : userScale);
  document.getElementById('zoomIn').addEventListener('click', ()=>{ const base = (mode==='fitW') ? lockedFit : userScale; mode='free'; userScale = clamp(base + 0.10, 0.2, 3); applyZoom(); });
  document.getElementById('zoomOut').addEventListener('click', ()=>{ const base = (mode==='fitW') ? lockedFit : userScale; mode='free'; userScale = clamp(base - 0.10, 0.2, 3); applyZoom(); });
  document.getElementById('zoomPct').addEventListener('click', ()=>{ mode='free'; userScale=1; applyZoom(); });
  document.getElementById('fitW').addEventListener('click', ()=>{ mode='fitW'; layout(); });

  function canPan(){
    const tol = 2;
    let needX = (mode!=='fitW') && ((scroller.offsetWidth - viewport.clientWidth) > tol);
    let needY = (scroller.offsetHeight - viewport.clientHeight) > tol;
    if(mode==='fitW'){
      needX = false;
      if(lastH && (lastH * Math.max(lockedFit, 0.0001) <= viewport.clientHeight - tol)) needY = false;
    }
    return needX || needY;
  }
  let isPanning=false, panPending=false, startX=0, startY=0, startScrollL=0, startScrollT=0;
  viewport.addEventListener('pointerdown', e=>{ if(e.button!==0) return; if(e.target.closest('.zoombar')||e.target.closest('.toggle')) return; if(!canPan()) return; panPending=true; isPanning=false; startX=e.clientX; startY=e.clientY; startScrollL=viewport.scrollLeft; startScrollT=viewport.scrollTop; });
  viewport.addEventListener('pointermove', e=>{ if(!(panPending||isPanning)) return; const dx=e.clientX-startX, dy=e.clientY-startY; if(!isPanning){ if(Math.abs(dx)+Math.abs(dy)<4) return; isPanning=true; try{viewport.setPointerCapture(e.pointerId);}catch(_){} viewport.style.cursor='grabbing'; } viewport.scrollLeft=startScrollL-dx; viewport.scrollTop=startScrollT-dy; });
  function endPan(){ panPending=false; isPanning=false; viewport.style.cursor=(canPan()? 'grab':'auto'); }
  viewport.addEventListener('pointerup', endPan); viewport.addEventListener('pointercancel', endPan); viewport.addEventListener('pointerleave', endPan);

  viewport.addEventListener('touchstart', e=>{ if(e.target.closest('.zoombar')||e.target.closest('.toggle')) return; if(e.touches.length===2){ pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); pinchStartScale = currentScale(); mode='free'; } }, {passive:true});
  viewport.addEventListener('touchmove', e=>{ if(e.touches.length===2 && pinchStartDist>0){ e.preventDefault(); const dist=Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); userScale=clamp(pinchStartScale * (dist / pinchStartDist), 0.2, 3); applyZoom(); } }, {passive:false});
  viewport.addEventListener('touchend', e=>{ if(e.touches.length<2){ pinchStartDist=0; } });

  viewport.addEventListener('wheel', e=>{ if(!e.ctrlKey) return; e.preventDefault(); mode='free'; const s = currentScale(); userScale = clamp(s * Math.exp(-e.deltaY/500), 0.2, 3); applyZoom(); }, {passive:false});

  document.getElementById('expandAll').addEventListener('click', ()=>{ (function open(n){ n.collapsed=false; n.children.forEach(open); })(root); layout(); });
  document.getElementById('collapseAll').addEventListener('click', ()=>{ (function close(n){ if(n!==root) n.collapsed=true; n.children.forEach(close); })(root); mode='free'; userScale=lockedFit; layout(); });

  // init
  const sizeViewport = ()=>{ const rect = viewport.getBoundingClientRect(); const avail = window.innerHeight - rect.top - 16; viewport.style.height = Math.max(320, Math.floor(avail)) + 'px'; };
  sizeViewport(); layout();
  window.addEventListener('resize', ()=>{ sizeViewport(); layout(); });
  if (document.fonts && document.fonts.ready) { document.fonts.ready.then(()=> layout()); }
})();
</script>
